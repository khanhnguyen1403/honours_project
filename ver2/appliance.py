from tkinter import *
import time

class Appliance:
    def __init__(self, name, ID):
        self.name = name
        self.power_status = False
        self.ID = ID
        
        # Initialize all possible properties
        self.type = 0  # 0: load, 1: source, 2: storage
        self.voltage_rating = 0
        self.power_rating = 0
        self.power = [0] * 300  # Array of 300 elements for power values (5mins)
        self.pwm = 0 # Pulse Width Modulation 
        self.fm = 0 # Frequency Modulation
        self.time_operated = 0 # in seconds
        self.energy_used = 0  # Wh
        self.fault = False

        # Additional properties for different appliance types
        # Load properties
        self.overvoltage_threshold = 0
        self.undervoltage_threshold = 0
        self.differential_threshold = 0
        
        # Source properties
        self.max_output_power = 0
        self.max_output_current = 0
        
        # Storage properties
        self.capacity = 0
        self.fm_charge = 0
        self.fm_discharge = 0

        # Tracking variables
        self.power_on_time = 0  # Track time when appliance is on
        self.last_update_time = time.time()

    def update_power_value(self, new_power_value):
        # Shift all values left by one position
        self.power[:-1] = self.power[1:]
        # Add new value at the end
        self.power[-1] = new_power_value
        
        # Update time operated if appliance is on
        current_time = time.time()
        if self.power_status:
            self.power_on_time += (current_time - self.last_update_time)
            self.time_operated = int(self.power_on_time)
            
            # Energy = Power * Time (in kWh)
            self.energy_used += (new_power_value * (current_time - self.last_update_time)) / 3600  # Convert to Wh
        
        self.last_update_time = current_time

    def get_current_power(self): # Instantaneous power 
        return self.power[-1]

    def get_power_history(self): # Return the array
        return self.power.copy()

    def properties(self):
        return {
            'name': self.name,
            'type': self.type,
            'power_status': self.power_status,
            'voltage_rating': self.voltage_rating,
            'power_rating': self.power_rating,
            'current_power': self.get_current_power(),
            'pwm': self.pwm,
            'fm': self.fm,
            'energy_used': self.energy_used,
            'time_operated': self.time_operated,
            'fault': self.fault
        }

    def toggle_power(self):
        if self.power_status:
            self.power_status = False
        else:
            self.power_status = True
            # Reset timing when turned on
            self.last_update_time = time.time()


    def get_status_text(self):
        return "ON" if self.power_status else "OFF"
    
    def get_status_color(self):
        return 'green' if self.power_status else 'red'

    def get_power_consumption(self):
        """Get current power consumption (for loads)"""
        if self.type == 0 and self.power_status:  # Load type and ON
            return self.get_current_power()
        return 0

    def get_power_generation(self):
        """Get current power generation (for sources)"""
        if self.type == 1 and self.power_status:  # Source type and ON
            return self.get_current_power()
        return 0


class Appliance_Summary:
    def __init__(self, name="All", ID=0):
        self.name = name
        self.ID = ID
        self.type = -1  # Special type for "All"
        self.power_status = True  # Always "active"
        
        # Summary properties
        self.total_power_consumption = 0    # Total power consumed by all loads
        self.total_power_generation = 0     # Total power generated by all sources
        self.total_energy_consumption = 0   # Total energy consumed by all appliances
        self.total_energy_generated = 0     # Total energy generated by all sources
        
        # Power history for summary
        self.power = [0] * 300  # Array tracking net power (generation - consumption)
        
        # Standard properties (for compatibility)
        self.voltage_rating = 240  # System voltage
        self.power_rating = 0
        self.fault = False
        self.time_operated = 0
        
    def update_power_value(self, consumption, generation):
        net_power = consumption - generation
        
        # Shift all values left by one position
        self.power[:-1] = self.power[1:]
        # Add new value at the end
        self.power[-1] = net_power
        
        # Update summary values
        self.total_power_consumption = consumption
        self.total_power_generation = generation
        
    def get_current_power(self):
        return self.power[-1]

    def get_power_history(self):
        return self.power.copy()
        

    def update_from_appliances(self, appliances_dict):
        """Update aggregate values from all individual appliances"""
        # Reset values
        total_consumption = 0
        total_generation = 0
        self.total_energy_consumption = 0
        self.total_energy_generated = 0
        total_time = 0
        active_count = 0
        
        # Aggregate data from all appliances
        for name, appliance in appliances_dict.items():
            if name == "All" or appliance is None:
                continue
                
            # Power consumption (loads)
            if appliance.type == 0:  # Load
                total_consumption += appliance.get_power_consumption()
                self.total_energy_consumption += appliance.energy_used
            
            # Power generation (sources) 
            elif appliance.type == 1:  # Source
                total_generation += appliance.get_power_generation()
                self.total_energy_generated += appliance.energy_used
            
            # Storage contributes to both consumption and generation based on mode
            elif appliance.type == 2:  # Storage
                self.total_energy_consumption += appliance.energy_used
            
            # Aggregate time operated
            if appliance.power_status:
                total_time += appliance.time_operated
                active_count += 1
        
        # Update current consumption and generation
        self.total_power_consumption = total_consumption
        self.total_power_generation = total_generation
        self.time_operated = total_time // active_count if active_count > 0 else 0
        
        # Update net power (generation - consumption)
        self.power_rating = total_generation - total_consumption

    def properties(self):
        """Return summary properties for 'All' appliances"""
        return {
            'name': self.name,
            'type': self.type,
            'total_power_consumption': self.total_power_consumption,
            'total_power_generation': self.total_power_generation,
            'total_energy_consumption': self.total_energy_consumption,
            'total_energy_generated': self.total_energy_generated,
            'net_power': self.power_rating,
            'system_voltage': self.voltage_rating,
            'fault': self.fault
        }

    def get_status_text(self):
        return "ON" if self.power_status else "OFF"
    
    def get_status_color(self):
        return 'green' if self.power_status else 'red'

    def toggle_power(self):
        if self.power_status:
            self.power_status = False
        else:
            self.power_status = True

    def get_power_consumption(self):
        return self.total_power_consumption

    def get_power_generation(self):
        return self.total_power_generation